%
% 
% Author: Richard Somervail, Istituto Italiano di Tecnologia, 2022
%           www.iannettilab.net
% History:
% 19/01/2023 ver 1.0.0 Created
% 
%%  

function EEG = pop_dusk2dawn_clean(EEG)

% get default savePath
if isempty( EEG.filepath )
    savePath_default = [cd filesep];
else
    savePath_default = [EEG.filepath filesep];
end
saveName_default = strrep( EEG.filename ,'.set','');


% get channel list
temp = EEG.chanlocs;
chanlist = cellfun( @(a,b) [ a '_' b ] , strsplit(num2str( [1:EEG.nbchan] )), {temp.labels}  , 'UniformOutput', false);

% set defaults
sw_autoFind_default = false;
fzs = strcmpi( {temp.labels}, 'FZ' );
if any( fzs )
    sw_autoFind_chan_default = find(fzs);
else
    sw_autoFind_chan_default = 1;
end
splitByStage_default = false;

% get relevant events (stages & slow-waves)
if ~isempty(EEG.event)

    ents = unique( {EEG.event.type} );
    
    ents_sw = ents(  contains(ents,'sw','IgnoreCase',true)  );
    ents_st = ents( ~contains(ents,'sw','IgnoreCase',true)  );

    if ~isempty(ents_sw) % if there are potential sw events
        temp = cellfun( @(x) ['''' x ''''] , ents_sw ,'UniformOutput' , false);
        temp = strjoin( temp, ', ' );
        ents_sw = ['{' temp '}']; clear temp
    else
        ents_sw = ' {   } ';
        sw_autoFind_default = true;
    end

    if ~isempty(ents_st) % if there are remaining potential sleep stage events
        temp = cellfun( @(x) ['''' x ''''] , ents_st ,'UniformOutput' , false);
        temp = strjoin( temp, ', ' );
        ents_st = ['{' temp '}']; clear temp
        splitByStage_default = true;
    else
        ents_st = ' {   } ';
    end

else
    ents_sw = ' * no event codes present * ';
    ents_st = ' * no event codes present * ';
    sw_autoFind_default = true;
end

%% create GUI
longbox  = [1 4]; % long box style input
mm = [1 1];
mmm = [1 1 1];
mmmm = [1 1 1 1];
medtext   = [2 1];
    geometry = { ...
            1 ... 
            1 ... % DUSK2DAWN OPTIONS
            [2 1] [2 1] ... % savePath & saveName
            1 ... 
            1 ... % ASR OPTIONS
            1 [1 5] ... % asr cutoff + help text
            1 ...  
            1 mmm [2 2 1 1]  ... % d2d options - split by stage
            1 ... 
            1 mmm [2 1 1 1 1] ...  % d2d options - split by chunk
            1 ...
            1 ... % Advanced Options (etc)
            mmm [1 1 1 1 2] ...  % advanced  asr settings
            1 ...
            1 ... % POST-CLEANING VALIDATION 
            1 mmm mmm ... % validation - FFT
            1 ...
            1 mmm mmm 1 [3 3 1.5 1.5] [3 3 1.5 1.5] mmm [2 1 1 2] ... % validation - SW  
            1 ...
            1 mmm [2 1 1 2] ... % validation - ICA
            };
    
uilist ={ ...
        {} ...
        { 'Style', 'text', 'string', 'GENERAL OPTIONS', 'fontweight', 'bold' } ...
        { 'Style', 'text', 'string', 'Save path (where to save datasets)' } ...
            { 'Style', 'text', 'string', 'Save name (file name)' } ...
        { 'Style', 'edit', 'string', savePath_default 'tag' 'savePath' } ... %, 'HorizontalAlignment', 'left'  } ... 
            { 'Style', 'edit', 'string', saveName_default 'tag' 'saveName' } ...
        {} ...
        { 'Style', 'text', 'string', 'ASR OPTIONS', 'fontweight', 'bold' } ...
        { 'Style', 'text', 'string', 'ASR cutoff(s) (SD cutoff for rejection)'} ...
        { 'Style', 'edit', 'string', '[  40  ]' 'tag' 'asr_cutoff'  } ...    
            { 'Style', 'text', 'string', ' - recommended range: 30 - 45 SD (we recommend trying several values, e.g. [30 : 5 : 45])'} ...
        {} ...
        { 'Style', 'checkbox', 'string' 'split by sleep stage before ASR cleaning?' 'value' splitByStage_default 'tag' 'splitByStage' } ...
        {} ...
            { 'Style', 'text', 'string', 'choose event codes which mark sleep stages '} ...
            { 'Style', 'text', 'string', 'choose window around sleep stage events (s)'} ...
        {} ...
            { 'Style', 'edit', 'string', ents_st ,  'tag' 'stageCodes'  } ...  
            { 'Style', 'edit', 'string', '[ 0, 30 ]' ,  'tag' 'stageWin'  } ...  
            {} ...
        {} ...
        { 'Style', 'checkbox', 'string' 'run ASR in a sliding window?' 'value' 1 'tag' 'splitBySlidingWindow' } ...    
        {} ...    
            { 'Style', 'text', 'string', 'choose length of sliding window (mins) '} ...
            { 'Style', 'text', 'string', 'choose overlap of sliding window (mins) '} ...
        {} ...    
            { 'Style', 'edit', 'string', '[   8   ]' 'tag' 'chunk_len'  } ... 
            {} ...
            { 'Style', 'edit', 'string', '[   1   ]' 'tag' 'chunk_overlap'  } ... 
            {} ...
        {} ...
        { 'Style', 'text', 'string', 'Advanced Options (you usually don''t need to worry about these)', 'FontAngle', 'italic'} ...
                { 'Style', 'text', 'string', 'RMS SD tolerances for acceptable calibration data: [min,max]'} ...
            { 'Style', 'text', 'string', '% max bad channels acceptable for calibration data'} ...
            {} ...
        { 'Style', 'edit', 'string', '[  -3.5,  5  ]' 'tag' 'ref_tolerances'  } ...  
            {} ...
            { 'Style', 'edit', 'string', '[   7.5   ]' 'tag' 'ref_maxbadchannels'  } ... 
            {} ...
            {} ...
        {} ...
        { 'Style', 'text', 'string', 'POST-CLEANING VALIDATION', 'fontweight', 'bold' } ...
        { 'Style', 'checkbox', 'string' '(1) Compute frequency spectrum before/after ASR?' 'value' 0 'tag' 'fft_run' } ...
        {} ...
            { 'Style', 'text', 'string', 'choose frequency bands (Hz): '} ...
            { 'Style', 'text', 'string', 'choose labels for each frequency band: '} ...
        {} ...
            { 'Style', 'edit', 'string', '[   1,4;  4,8;  8,12; 12,16;  18,30;   30,45;  45,100    ]' 'tag' 'fft_binFreqs'  } ...
            { 'Style', 'edit', 'string', ' {   ''delta''; ''theta''; ''alpha''; ''sigma''; ''beta''; ''gammaLow''; ''gammaHigh''    } ' 'tag' 'fft_binFreqsLabels'  } ...             
        {} ...
        { 'Style', 'checkbox', 'string' '(2) Measure slow-wave amplitude before/after ASR?' 'value' 0 'tag' 'sw_run' } ...
        {} ...
            { 'Style', 'text', 'string', 'choose event codes which mark slow waves: '} ...
            {} ...
        {} ...
            { 'Style', 'edit', 'string', ents_sw ,  'tag' 'sw_codes'  } ...  
            {} ...
        {} ...
        {} ...
            { 'Style', 'checkbox', 'string' 'OR detect slow-waves automatically (swalldetectnew):' 'value' sw_autoFind_default 'tag' 'sw_autoFind' } ...    
            { 'Style', 'text', 'string', 'channel:'} ...
            { 'Style', 'text', 'string', 'amplitude threshold:'} ...
        {} ... 
            {} ... 
            { 'Style', 'popupmenu', 'string', chanlist , 'value', sw_autoFind_chan_default,  'tag' 'sw_autoFind_chan'  } ... 
            { 'Style', 'edit', 'string', '0' ,  'tag' 'sw_autoFind_ampThresh'  } ...  
        {} ...
            { 'Style', 'text', 'string', 'choose window around SW peak (ms)'} ...
            {} ...
        {} ...
            { 'Style', 'edit', 'string', '[ -50  50 ]' ,  'tag' 'sw_peakwin'  } ...  
            {} ...
            {} ...
        {} ...
        { 'Style', 'checkbox', 'string' '(3) Assess ICA quality before/after ASR using IClabel?' 'value' 0 'tag' 'ica_run' } ... 
        { 'Style', 'text', 'string', '         ** requires channel locations **' } ...
            { 'Style', 'text', 'string', ['choose number of independent components (max = ' num2str(EEG.nbchan) ')' ]  } ...
            {} ...
        {} ...
            { 'Style', 'edit', 'string', num2str(EEG.nbchan) ,  'tag' 'ica_numIC'  } ...  
            {} ...
            {} ...
    };

      [ tmp1 tmp2 strhalt cfg ] = inputgui( geometry, uilist, ...
           'pophelp(''pop_dusk2dawn'');', 'Clean whole-night dataset with ASR -- pop_dusk2dawn_clean()');
 
%% make save directory if doesn't exist yet
if ~exist(cfg.savePath,'dir')
    mkdir(cfg.savePath);
end

%% store & reformat parameters
if strcmp(cfg.stageCodes, ' * no event codes present * '), cfg.stageCodes = '[]'; end
evalc([ 'cfg.stageCodes = ' cfg.stageCodes  ]);
evalc([ 'cfg.stageWin = ' cfg.stageWin ]);
if ~cfg.splitBySlidingWindow
    cfg.chunk_len     = nan;
    cfg.chunk_overlap = nan;
else
    evalc([ 'cfg.chunk_len = ' cfg.chunk_len ]);
    evalc([ 'cfg.chunk_overlap = ' cfg.chunk_overlap ]);
end
evalc([ 'cfg.ref_maxbadchannels = ' cfg.ref_maxbadchannels ]);
cfg.ref_maxbadchannels  = cfg.ref_maxbadchannels / 100; % convert MaxBadChannels to proportions for clean_windows function
evalc([ 'cfg.ref_tolerances = ' cfg.ref_tolerances ]);
evalc([ 'cfg.asr_cutoff = ' cfg.asr_cutoff ]);   %#ok<*EVLEQ> 
% validation - fft
cfg.fft.run = cfg.fft_run; cfg = rmfield(cfg,'fft_run');
evalc([ 'cfg.fft.binFreqs = ' cfg.fft_binFreqs ]); cfg = rmfield(cfg,'fft_binFreqs');
evalc([ 'cfg.fft.binFreqsLabels = ' cfg.fft_binFreqsLabels ]); cfg = rmfield(cfg,'fft_binFreqsLabels');
% validation - sw
cfg.sw.run = cfg.sw_run; cfg = rmfield(cfg,'sw_run');
if strcmp(cfg.sw_codes, ' * no event codes present * '), cfg.sw_codes = '[]'; end
evalc([ 'cfg.sw.codes = ' cfg.sw_codes ]); cfg = rmfield(cfg,'sw_codes');
cfg.sw.autoFind = cfg.sw_autoFind; cfg = rmfield(cfg,'sw_autoFind');
cfg.sw.autoFind_chan = cfg.sw_autoFind_chan; cfg = rmfield(cfg,'sw_autoFind_chan');
evalc([ 'cfg.sw.autoFind_ampThresh = ' cfg.sw_autoFind_ampThresh ]); cfg = rmfield(cfg,'sw_autoFind_ampThresh');
evalc([ 'cfg.sw.peakwin = ' cfg.sw_peakwin ]); cfg = rmfield(cfg,'sw_peakwin');
cfg.sw.peakwin = cfg.sw.peakwin / 1000; % convert from ms to s
% validation - ica
cfg.ica.run = cfg.ica_run; cfg = rmfield(cfg,'ica_run');
evalc([ 'cfg.ica.numIC = ' cfg.ica_numIC ]); cfg = rmfield(cfg,'ica_numIC');

% % check options were appropriate for these data
% if cfg.ica.run && sum(isempty(),'all') % ? not sure which chanlocs are necessary for IClabel
%     warning 'pop_dusk2dawn: '
% end

% call dusk2dawn cleaning function
EEG = dusk2dawn_clean(EEG, cfg); 

end
